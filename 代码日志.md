# 2026-2-3

- [x] **实现读取字符串中的地区时间天气的提取**

```c
static void Handle_AT_GET_CLOCK_WEATHER(const char* buf)
{
    char* p;

    // 1. 提取温度 (使用你最喜欢的 strlen 方案)
    p = strstr(buf, "\"temperature\":");
    if (p != NULL) {
        // +strlen("\"temperature\":") 会直接跳到冒号后面
        // 如果数据是 "temperature":"2"，跳过后指向 "2"
        p += strlen("\"temperature\":") + 1; 
        Cur_Time.temperature = (int8_t)atoi(p);
    }

    // 2. 提取天气代码
    p = strstr(buf, "\"code\":");
    if (p != NULL) {
        p += strlen("\"code\":") + 1; 
        Cur_Time.weather_code = (uint8_t)atoi(p);
    }

    // 3. 提取时间 (注意下划线 _)
    p = strstr(buf, "\"last_update\":");
    if (p != NULL) {
        // 跳过 "last_update":" 这 15 个字节
        p += 15; 
        // 格式：%hu 是 uint16_t, %hhu 是 uint8_t
        // 注意：有些编译器 sscanf 不支持 %hhu，如果报错请改用临时 int 中转
        sscanf(p, "%hu-%hhu-%hhuT", 
               &Cur_Time.year, &Cur_Time.month, &Cur_Time.day);
    }
    
    print("天气:%d\r\n温度:%d\r\n时间:%d-%d-%d %d:%d:%d",Cur_Time.weather_code,Cur_Time.temperature, 
    Cur_Time.year,Cur_Time.month,Cur_Time.day,Cur_Time.hour,Cur_Time.min,Cur_Time.sec
    );
}
static void Handle_AT_GET_NTP_TIME(const char*buf)
{
   char *p = strstr(buf, "+CIPSNTPTIME:");
if(p != NULL) {
        // 注意：NTP 格式非常固定，但要数准空格
        // 用 sscanf 匹配这种带月份缩写的格式
        // 格式说明：%*s 代表跳过一个字符串（比如跳过 Tue 和 Feb）
      sscanf(p, "+CIPSNTPTIME:%*s %*s %hhu %hhu:%hhu:%hhu %hu", 
             &Cur_Time.day, 
             &Cur_Time.hour, 
             &Cur_Time.min, 
             &Cur_Time.sec, 
             &Cur_Time.year);
    }
}

```

- [x] *将创建的闹钟保存到W25Q128中(分配一个扇区4096字节来存放创建的闹钟,并实现滚动储存,因为每次写入都要擦除,但是最多创建十个闹钟中,这样很浪费w25q的擦除寿命,每128字节保存闹钟,用完了才会擦除)*

```c
/*--------------------------------------------------------------------------------↓
	@函数	  :  读取保存的闹钟
	@参数	  :
	@返回值 :
	@备注	  :
↑--------------------------------------------------------------------------------*/
// 返回最新数据的索引 (0-31)，如果没有数据则返回 0xFF
uint8_t Get_Latest_Alarm_Index(uint32_t Address)
{
    uint8_t flag;
    
    for(uint8_t i = 0; i < (4096 / ALARM_SAVE_BLOT_SIZE); i++)
    {
        // 我们只需要读取每个 Slot 的第一个字节（标志位）即可，没必要读整个结构体，速度更快
        W25Qxx_ReadData(Address + (i * ALARM_SAVE_BLOT_SIZE), &flag, 1);
        
        if(flag == 0xFF) // 发现空位
        { 
            if(i == 0) return 0xFF; // 情况1：第0个就是空的，说明扇区完全没写过
            return i - 1;          // 情况2：找到了空位，那上一个就是最新的
        }
    }
    
    // 情况3：循环走完了都没发现 0xFF，说明 32 个槽位全满了
    return (4096 / ALARM_SAVE_BLOT_SIZE) - 1; 
}


/*--------------------------------------------------------------------------------↓
	@函数	  :
	@参数	  :
	@返回值 :
	@备注	  :
↑--------------------------------------------------------------------------------*/

void Alarm_System_Init(void)
{
  uint8_t LastIndex=Get_Latest_Alarm_Index(ALARM_CLOCK_SAVE_Addr);
  if(LastIndex==0XFF)
  {
    /*没有闹钟*/
    print("没有闹钟\r\n");
  }
  else
  {
    W25Qxx_ReadData(ALARM_CLOCK_SAVE_Addr+LastIndex*ALARM_SAVE_BLOT_SIZE,(uint8_t*)&alarm_clock,sizeof(alarm_clock_t));
    if(alarm_clock.save_flag==ALARM_SAVE_FLAG)
    {
      /*读取成功*/
      print("读取成功\r\n");
    }
    else
    {
     alarm_clock.save_alarm_num=0;
     print("读取闹钟失败\r\n");
    }
  }
}


/*--------------------------------------------------------------------------------↓
	@函数	  : 保存闹钟
	@参数	  :
	@返回值 :
	@备注	  :
↑--------------------------------------------------------------------------------*/
void save_alarm_data(void)
{
    uint8_t LastIndex=Get_Latest_Alarm_Index(ALARM_CLOCK_SAVE_Addr);
    uint8_t Target_index=0;
    if(LastIndex==0XFF)
    {
      /*直接在第一个位置写就行*/
      Target_index=0;
      print("直接在第一个位置写就行\r\n");
    }
    else if(LastIndex==(4096/ALARM_SAVE_BLOT_SIZE)-1)
    {
      /*说明写满了,擦除扇区从头写*/
      W25Qxx_SectorErase(ALARM_CLOCK_SAVE_Addr);
      Target_index=0;
      print("说明写满了,擦除扇区从头写\r\n");
    }
    else
    {
      /*还有空间可以直接写*/
      Target_index=LastIndex+1;
      print("还有空间可以直接写\r\n");
    }
    alarm_clock.save_flag=ALARM_SAVE_FLAG;
    W25Qxx_WriteBuffer(ALARM_CLOCK_SAVE_Addr+Target_index*ALARM_SAVE_BLOT_SIZE,(const uint8_t*)&alarm_clock,sizeof(alarm_clock_t));
    
}

```

# 2026-2-4

